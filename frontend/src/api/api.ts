/* tslint:disable */
/* eslint-disable */
/**
 * TIRVerifier
 * Specifies the models and endpoints used in Trusted Issuer Registry resolution and issuer verification.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * A schema defining in more or less detail how a Verifiable Credential may look like.
 * @export
 * @interface CredentialSchema
 */
export interface CredentialSchema {
    /**
     * A URI linking to an external resource containing the actual schema.
     * @type {string}
     * @memberof CredentialSchema
     */
    'id': string;
    /**
     * A string defining the schema\'s type. As verifiable credentials are often presented in a JSON format, we expect \'JsonSchema\' to be a common value here, referring to the [JSON Schema specification](https://json-schema.org/).
     * @type {string}
     * @memberof CredentialSchema
     */
    'type': string;
    /**
     * A SHA-256 hash of the external resource the \"id\" property refers to.
     * @type {string}
     * @memberof CredentialSchema
     */
    'hash': string;
    /**
     * A boolean value that defines whether the trust defined in the schema can be delegated. This value is important in the event that the issuer operates its own TIR, a sub-registry, under its DID. If the schema is inheritable, the TIR also trusts the issuers in the issuer\'s sub-registry within the set schema restriction.
     * @type {boolean}
     * @memberof CredentialSchema
     */
    'inheritable': boolean;
}
/**
 * A potentially incomplete TIR with additional properties for fetching specific issuer\'s data (expanding) in case the TIR uses the \"Tezos\" TIR method, which does not allow fetching all issuers at once.
 * @export
 * @interface ExpandableTIR
 */
export interface ExpandableTIR {
    /**
     * The TIR method identifier, e.g., \"Web\".
     * @type {any}
     * @memberof ExpandableTIR
     */
    'method': any;
    /**
     * A constant natural number defining the protocol version of the TIR method. The property enables protocol participants to detect future protocol changes.
     * @type {any}
     * @memberof ExpandableTIR
     */
    'methodProtocol': any;
    /**
     * The protocol version of the TIR.
     * @type {any}
     * @memberof ExpandableTIR
     */
    'protocol': any;
    /**
     * The DID of the TIR\'s maintainer. This backlink enables serializing the TIR into a Verifiable Credential.
     * @type {any}
     * @memberof ExpandableTIR
     */
    'issuer': any;
    /**
     * An ISO 8601 timestamp denoting the last time the TIR was updated. This property allows for smarter caching and thus faster resolution of the TIR. In addition this property becomes the issuanceDate property of the TIR\'s Verifiable Credential.
     * @type {any}
     * @memberof ExpandableTIR
     */
    'lastUpdated': any;
    /**
     * Time To Live. The cache expiration in seconds. 
     * @type {any}
     * @memberof ExpandableTIR
     */
    'ttl': any;
    /**
     * An object that enables additional metadata-key-value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof ExpandableTIR
     */
    'extraMetadata': { [key: string]: any; };
    /**
     * A JSON Map of Issuers
     * @type {{ [key: string]: Issuer; }}
     * @memberof ExpandableTIR
     */
    'issuers': { [key: string]: Issuer; };
    /**
     * The DID from which the TIR was resolved. Often, this will match the TIR\'s issuer property.
     * @type {string}
     * @memberof ExpandableTIR
     */
    'did'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandableTIR
     */
    'expandedIssuerIds'?: Array<string>;
    /**
     * A not further specified object in which a Tezos BigMapAbstraction can be stored. This can be used to fetch individual objects from the Big-map. This is important because the objects of a Tezos Big-map cannot be retrieved all at once, but only individually. To provide the user with this functionality, this property must be passed.
     * @type {object}
     * @memberof ExpandableTIR
     */
    'issuersMichelsonMap'?: object;
}
/**
 * 
 * @export
 * @interface ExpandableTezosTIR
 */
export interface ExpandableTezosTIR {
    /**
     * The TIR method identifier, e.g., \"Web\".
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'method': any;
    /**
     * A constant natural number defining the protocol version of the TIR method. The property enables protocol participants to detect future protocol changes.
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'methodProtocol': any;
    /**
     * The protocol version of the TIR.
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'protocol': any;
    /**
     * The DID of the TIR\'s maintainer. This backlink enables serializing the TIR into a Verifiable Credential.
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'issuer': any;
    /**
     * An ISO 8601 timestamp denoting the last time the TIR was updated. This property allows for smarter caching and thus faster resolution of the TIR. In addition this property becomes the issuanceDate property of the TIR\'s Verifiable Credential.
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'lastUpdated': any;
    /**
     * Time To Live. The cache expiration in seconds. 
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'ttl': any;
    /**
     * An object that enables additional metadata-key-value pairs.
     * @type {{ [key: string]: any; }}
     * @memberof ExpandableTezosTIR
     */
    'extraMetadata': { [key: string]: any; };
    /**
     * A JSON Map of Issuers
     * @type {{ [key: string]: Issuer; }}
     * @memberof ExpandableTezosTIR
     */
    'issuers': { [key: string]: Issuer; };
    /**
     * The DID from which the TIR was resolved. Often, this will match the TIR\'s issuer property.
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'did'?: any;
    /**
     * 
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'expandedIssuerIds'?: any;
    /**
     * A not further specified object in which a Tezos BigMapAbstraction can be stored. This can be used to fetch individual objects from the Big-map. This is important because the objects of a Tezos Big-map cannot be retrieved all at once, but only individually. To provide the user with this functionality, this property must be passed.
     * @type {any}
     * @memberof ExpandableTezosTIR
     */
    'issuersMichelsonMap'?: any;
    /**
     * A Tezos address identifying the account that is allowed to make changes to the contract.
     * @type {string}
     * @memberof ExpandableTezosTIR
     */
    'owner': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExpandableTezosTIR
     */
    'issuerIds': Array<string>;
}
/**
 * 
 * @export
 * @interface GetResolveDidRequest
 */
export interface GetResolveDidRequest {
    /**
     * 
     * @type {string}
     * @memberof GetResolveDidRequest
     */
    'did': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetResolveDidRequest
     */
    'tezosOnlyIssuerIds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetResolveDidRequest
     */
    'noCache'?: boolean;
}
/**
 * A trusted issuer inside a Trusted Issuer Registry with all the information about the scope and context of trust in the issuer.
 * @export
 * @interface Issuer
 */
export interface Issuer {
    /**
     * A unique identifier for the issuer in URI format.
     * @type {string}
     * @memberof Issuer
     */
    'id': string;
    /**
     * A start date in ISO 8601 format since when the issuer is trusted.
     * @type {string}
     * @memberof Issuer
     */
    'trustedSince'?: string;
    /**
     * An end date in ISO 8601 format until when the issuer is trusted.
     * @type {string}
     * @memberof Issuer
     */
    'trustedUntil'?: string;
    /**
     * Whether the trust in the issuer has been revoked, e.g., because it turned out that the issuer is malicious.
     * @type {boolean}
     * @memberof Issuer
     */
    'revoked'?: boolean;
    /**
     * A string field that maintainers can use to define the trust in the issuer in natural language. The value enables maintainers to decide for themselves how to balance the trade-off between detailed trust specification and broad delegation of trust.
     * @type {string}
     * @memberof Issuer
     */
    'tcDescription'?: string;
    /**
     * A string field that maintainers can use to connect an issuer with his legal identity. We have refrained from specifying the field in detail, as the requirements vary depending on the application. Maintainers can fill the field with natural language or structured data like a serialized JSON map.
     * @type {string}
     * @memberof Issuer
     */
    'tcIdentity'?: string;
    /**
     * 
     * @type {Array<CredentialSchema>}
     * @memberof Issuer
     */
    'credentialSchemas'?: Array<CredentialSchema>;
}
/**
 * 
 * @export
 * @interface IssuerResult
 */
export interface IssuerResult {
    /**
     * Whether the verification for this trust path entity was successfull.
     * @type {boolean}
     * @memberof IssuerResult
     */
    'valid': boolean;
    /**
     * The issuer information of the trust path issuer.
     * @type {Issuer}
     * @memberof IssuerResult
     */
    'issuer'?: Issuer;
    /**
     * 
     * @type {Array<VerificationFraction>}
     * @memberof IssuerResult
     */
    'verifications': Array<VerificationFraction>;
}
/**
 * 
 * @export
 * @interface PostResolveTIR200Response
 */
export interface PostResolveTIR200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof PostResolveTIR200Response
     */
    'resolvedIssuerIds': Array<string>;
}
/**
 * 
 * @export
 * @interface PostResolveTIRRequest
 */
export interface PostResolveTIRRequest {
    /**
     * 
     * @type {string}
     * @memberof PostResolveTIRRequest
     */
    'did': string;
}
/**
 * 
 * @export
 * @interface PostSetAutoResolveDIDRequest
 */
export interface PostSetAutoResolveDIDRequest {
    /**
     * 
     * @type {string}
     * @memberof PostSetAutoResolveDIDRequest
     */
    'did': string;
}
/**
 * 
 * @export
 * @interface PostVerifyRequest
 */
export interface PostVerifyRequest {
    /**
     * The id of the issuer that should be verified.
     * @type {string}
     * @memberof PostVerifyRequest
     */
    'id'?: string;
    /**
     * An ISO 8601 timestamp for which the trustworthiness of the issuer is to be verified.
     * @type {string}
     * @memberof PostVerifyRequest
     */
    'timestamp'?: string;
    /**
     * A Verfiable Credential in JSON syntax, at least needed to check it against Credential Schemas. In case no id and/or timestamp is provided, \"issuer\" and \"issuanceDate\" properties from the VC will be used. JWT VCs must be decoded first (https://www.w3.org/TR/vc-data-model/#jwt-decoding).
     * @type {object}
     * @memberof PostVerifyRequest
     */
    'vc'?: object;
}
/**
 * A Trusted Issuer Registry containing trusted issuers and metadata describing the TIR.
 * @export
 * @interface TIR
 */
export interface TIR {
    /**
     * The TIR method identifier, e.g., \"Web\".
     * @type {string}
     * @memberof TIR
     */
    'method': string;
    /**
     * A constant natural number defining the protocol version of the TIR method. The property enables protocol participants to detect future protocol changes.
     * @type {number}
     * @memberof TIR
     */
    'methodProtocol': number;
    /**
     * The protocol version of the TIR.
     * @type {number}
     * @memberof TIR
     */
    'protocol': number;
    /**
     * The DID of the TIR\'s maintainer. This backlink enables serializing the TIR into a Verifiable Credential.
     * @type {string}
     * @memberof TIR
     */
    'issuer': string;
    /**
     * An ISO 8601 timestamp denoting the last time the TIR was updated. This property allows for smarter caching and thus faster resolution of the TIR. In addition this property becomes the issuanceDate property of the TIR\'s Verifiable Credential.
     * @type {string}
     * @memberof TIR
     */
    'lastUpdated': string;
    /**
     * Time To Live. The cache expiration in seconds. 
     * @type {number}
     * @memberof TIR
     */
    'ttl': number;
    /**
     * An object that enables additional metadata-key-value pairs.
     * @type {{ [key: string]: string; }}
     * @memberof TIR
     */
    'extraMetadata': { [key: string]: string; };
    /**
     * A JSON Map of Issuers
     * @type {{ [key: string]: Issuer; }}
     * @memberof TIR
     */
    'issuers': { [key: string]: Issuer; };
}
/**
 * A small part of an issuer\'s path verification concerning one issuer of the path and one single verification, like whether a schema was found.
 * @export
 * @interface VerificationFraction
 */
export interface VerificationFraction {
    /**
     * Describes in 1-2 words the type of verification.
     * @type {string}
     * @memberof VerificationFraction
     */
    'title': string;
    /**
     * Whether the verification is valid, invalid, or in case of undefined, not performed
     * @type {boolean}
     * @memberof VerificationFraction
     */
    'valid'?: boolean;
    /**
     * A message giving details on the verification\'s result. For example: \"The verfication date is before the issuer\'s trustedSince timestamp.\"
     * @type {string}
     * @memberof VerificationFraction
     */
    'message'?: string;
}
/**
 * The result of an issuer verification. Gives the overall result and detailed subresults for every issuer on the trust path.
 * @export
 * @interface VerificationResult
 */
export interface VerificationResult {
    /**
     * Whether the issuer is trusted overall.
     * @type {boolean}
     * @memberof VerificationResult
     */
    'valid': boolean;
    /**
     * 
     * @type {Array<IssuerResult>}
     * @memberof VerificationResult
     */
    'issuerResults': Array<IssuerResult>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resolves a single TIR from a DID without resolving subregistries.
         * @summary Resolve Single TIR
         * @param {string} did 
         * @param {GetResolveDidRequest} [getResolveDidRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolveDid: async (did: string, getResolveDidRequest?: GetResolveDidRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'did' is not null or undefined
            assertParamExists('getResolveDid', 'did', did)
            const localVarPath = `/resolveSingleTIR/{did}`
                .replace(`{${"did"}}`, encodeURIComponent(String(did)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getResolveDidRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a full TIR resolution including sub-registries and caching of the result.
         * @summary Resolve TIR and Cache Result
         * @param {PostResolveTIRRequest} [postResolveTIRRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResolveTIR: async (postResolveTIRRequest?: PostResolveTIRRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resolveTIR`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postResolveTIRRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the DID that will be automatically resolved by the CRON job.
         * @summary Set AutoResolve DID
         * @param {PostSetAutoResolveDIDRequest} [postSetAutoResolveDIDRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetAutoResolveDID: async (postSetAutoResolveDIDRequest?: PostSetAutoResolveDIDRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setAutoResolveDID`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSetAutoResolveDIDRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies an issuer by its ID.
         * @summary Issuer Verification
         * @param {PostVerifyRequest} [postVerifyRequest] Requires either the id or the VC to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerify: async (postVerifyRequest?: PostVerifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Resolves a single TIR from a DID without resolving subregistries.
         * @summary Resolve Single TIR
         * @param {string} did 
         * @param {GetResolveDidRequest} [getResolveDidRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResolveDid(did: string, getResolveDidRequest?: GetResolveDidRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandableTIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResolveDid(did, getResolveDidRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getResolveDid']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Triggers a full TIR resolution including sub-registries and caching of the result.
         * @summary Resolve TIR and Cache Result
         * @param {PostResolveTIRRequest} [postResolveTIRRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postResolveTIR(postResolveTIRRequest?: PostResolveTIRRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostResolveTIR200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postResolveTIR(postResolveTIRRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.postResolveTIR']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Sets the DID that will be automatically resolved by the CRON job.
         * @summary Set AutoResolve DID
         * @param {PostSetAutoResolveDIDRequest} [postSetAutoResolveDIDRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSetAutoResolveDID(postSetAutoResolveDIDRequest?: PostSetAutoResolveDIDRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSetAutoResolveDID(postSetAutoResolveDIDRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.postSetAutoResolveDID']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Verifies an issuer by its ID.
         * @summary Issuer Verification
         * @param {PostVerifyRequest} [postVerifyRequest] Requires either the id or the VC to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVerify(postVerifyRequest?: PostVerifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postVerify(postVerifyRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.postVerify']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Resolves a single TIR from a DID without resolving subregistries.
         * @summary Resolve Single TIR
         * @param {string} did 
         * @param {GetResolveDidRequest} [getResolveDidRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolveDid(did: string, getResolveDidRequest?: GetResolveDidRequest, options?: any): AxiosPromise<ExpandableTIR> {
            return localVarFp.getResolveDid(did, getResolveDidRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a full TIR resolution including sub-registries and caching of the result.
         * @summary Resolve TIR and Cache Result
         * @param {PostResolveTIRRequest} [postResolveTIRRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResolveTIR(postResolveTIRRequest?: PostResolveTIRRequest, options?: any): AxiosPromise<PostResolveTIR200Response> {
            return localVarFp.postResolveTIR(postResolveTIRRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the DID that will be automatically resolved by the CRON job.
         * @summary Set AutoResolve DID
         * @param {PostSetAutoResolveDIDRequest} [postSetAutoResolveDIDRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSetAutoResolveDID(postSetAutoResolveDIDRequest?: PostSetAutoResolveDIDRequest, options?: any): AxiosPromise<void> {
            return localVarFp.postSetAutoResolveDID(postSetAutoResolveDIDRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies an issuer by its ID.
         * @summary Issuer Verification
         * @param {PostVerifyRequest} [postVerifyRequest] Requires either the id or the VC to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVerify(postVerifyRequest?: PostVerifyRequest, options?: any): AxiosPromise<VerificationResult> {
            return localVarFp.postVerify(postVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Resolves a single TIR from a DID without resolving subregistries.
     * @summary Resolve Single TIR
     * @param {string} did 
     * @param {GetResolveDidRequest} [getResolveDidRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getResolveDid(did: string, getResolveDidRequest?: GetResolveDidRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getResolveDid(did, getResolveDidRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a full TIR resolution including sub-registries and caching of the result.
     * @summary Resolve TIR and Cache Result
     * @param {PostResolveTIRRequest} [postResolveTIRRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postResolveTIR(postResolveTIRRequest?: PostResolveTIRRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postResolveTIR(postResolveTIRRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the DID that will be automatically resolved by the CRON job.
     * @summary Set AutoResolve DID
     * @param {PostSetAutoResolveDIDRequest} [postSetAutoResolveDIDRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSetAutoResolveDID(postSetAutoResolveDIDRequest?: PostSetAutoResolveDIDRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postSetAutoResolveDID(postSetAutoResolveDIDRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies an issuer by its ID.
     * @summary Issuer Verification
     * @param {PostVerifyRequest} [postVerifyRequest] Requires either the id or the VC to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postVerify(postVerifyRequest?: PostVerifyRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postVerify(postVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



